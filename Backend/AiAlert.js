
//Class representing the configurable limits (Normal, Borderline, Abnormal).Clinic Staff manages these.
class CategoryThreshold {
    constructor(name, min, max, priority) {
        this.name = name;
        this.minValue = min;
        this.maxValue = max;
        // Priority helps when filtering. Abnormal should be checked last if ranges overlap.
        this.priority = priority; 
    }

    [cite_start]// Method to check if a value falls within the thresholdâ€™s range.
    withInRange(value) {
        return value >= this.minValue && value <= this.maxValue;
    }
}

//Class representing a single blood sugar measurement and associated context.
 
class BloodSugarReading {
    [cite_start]// We'll use a placeholder readingId because we don't have a database to work now
    constructor(patientId, value, foodIntake, activity, notes, timestamp) {
        this.readingId = Math.floor(Math.random() * 10000); 
        this.patientId = patientId;
        this.value = value;
        this.timestamp = timestamp || new Date(); 
        this.foodIntake = foodIntake || 'N/A';
        this.activity = activity || 'N/A';
        this.notes = notes || 'N/A';
        this.category = 'Pending'; [cite_start]// Automatically assigned level
    }

    [cite_start]//Method to determine and assign the correct category.
    categorizeReading(thresholds) {
        // Sort thresholds by priority to ensure 'Normal' is evaluated before 'Borderline', etc., 
        // to handle edge cases if the ranges are configured poorly.
        thresholds.sort((a, b) => a.priority - b.priority);

        for (const threshold of thresholds) {
            if (threshold.withInRange(this.value)) {
                this.category = threshold.name; 
                return this.category;
            }
        }
        // Fallback for values outside all defined ranges (e.g., extremely high or low)
        this.category = 'Abnormal (Extreme)';
        return this.category;
    }
}

// Class representing a personalized health suggestion.
 
class Recommendation {
    constructor(patientId, advice, source = 'AI') {
        this.recId = Math.floor(Math.random() * 1000);
        this.patientId = patientId;
        this.advice = advice; [cite_start]// Personalized text suggestion
        this.createdAt = new Date();
        this.source = source; [cite_start]// Indicate whether this is generated by AI or Specialist.
    }
}

// Class representing the patient user.
 
class Patient {
    constructor(userId, userName, specialistEmail) {
        this.userId = userId;
        this.userName = userName;
        this.specialistEmail = specialistEmail;
        this.readings = []; [cite_start]// Stores BloodSugarReading objects.
        [cite_start]// Default System Thresholds (Can be customized by Clinic Staff/Patient).
        this.thresholds = [
            new CategoryThreshold('Normal', 70, 140, 1),
            new CategoryThreshold('Borderline', 141, 199, 2),
            new CategoryThreshold('Abnormal', 200, 9999, 3), 
            new CategoryThreshold('Abnormal', 0, 69, 3) // For low readings
        ];
    }
    
    [cite_start]// Patient functionality: Input a new reading.
    inputReading(value, foodIntake, activity, notes, timestamp) {
        // Step 1: Create a reading
        const newReading = new BloodSugarReading(this.userId, value, foodIntake, activity, notes, timestamp);
        
        [cite_start]// Step 2: Automated Functionality: Categorize the reading[cite: 7].
        newReading.categorizeReading(this.thresholds);

        // Step 3: Placeholder for database storage 
        // LATER: database.saveReading(newReading); 
        this.readings.push(newReading);
        
        return newReading;
    }
}

// AI engine logic

const AIEngine = {
    //Core threshold for the AI check (more than 3 abnormal readings).
    ABNORMAL_THRESHOLD: 3, 
    SEVEN_DAYS_MS: 7 * 24 * 60 * 60 * 1000,
    
    //Implements the detectAbnormal and sendAlert methods. Checks for the 3-per-week abnormal pattern and triggers the alert.
    
    runAlertCheck: function(patient) {
        const cutoffDate = new Date(Date.now() - this.SEVEN_DAYS_MS);

        [cite_start]//  Filter readings within the last 7 days and count abnormal ones.
        const recentAbnormalReadings = patient.readings.filter(reading => {
            return reading.timestamp >= cutoffDate && reading.category === 'Abnormal';
        });

        if (recentAbnormalReadings.length > this.ABNORMAL_THRESHOLD) {
            console.log(`\nðŸš¨ ALERT TRIGGERED for ${patient.userName}!`);
            console.log(`Reason: ${recentAbnormalReadings.length} Abnormal readings in the last week.`);
            
            [cite_start]// Run pattern analysis to generate a targeted recommendation.
            const recommendation = this.generateRecommendations(patient, recentAbnormalReadings);

            [cite_start]// System will pop up alert windows/send email alert within 15 mins.
            this.sendAlert(patient.userName, patient.specialistEmail, recommendation.advice);

        } else {
            console.log(`\nâœ… AI Check for ${patient.userName}: Status OK (${recentAbnormalReadings.length} abnormal readings this week).`);
        }
    },
    
    //Implements the analyzePatterns and generateRecommendations methods[cite: 488, 491]. This is where the core Machine Learning/Data Mining logic would go.
     
    generateRecommendations: function(patient, abnormalReadings) {
        [cite_start]// Examine patient history to detect recurring trends.
        
        // Simple Pattern Detection Placeholder
        [cite_start]// Use clustering or ML models here ( Apply the moving average or clustering algorithm).
        
        // For now, we'll just count the top food/activity associated with the abnormal readings.
        const triggers = {};
        abnormalReadings.forEach(r => {
            // Treat food and activity as separate potential triggers
            triggers[r.foodIntake] = (triggers[r.foodIntake] || 0) + 1;
            triggers[r.activity] = (triggers[r.activity] || 0) + 1;
        });

        // Find the top trigger (most frequent food or activity)
        let topTrigger = 'unidentified factors';
        let maxCount = 0;
        for (const [key, count] of Object.entries(triggers)) {
            if (count > maxCount && key !== 'N/A') {
                maxCount = count;
                topTrigger = key;
            }
        }

        let advice;
        if (topTrigger !== 'unidentified factors' && maxCount >= 2) {
            [cite_start]// AI generate personalized suggestions for user based on the pattern it identified.
            advice = `Warning: The AI identified a strong correlation between your high readings and "${topTrigger}" (seen ${maxCount} times). Please try reducing/modifying this for the next week and track your sugar levels.`;
        } else {
            advice = `The AI detected ${abnormalReadings.length} abnormal readings. Please review your logs with your specialist as no single dominant trigger (food/activity) was identified.`;
        }
        
        // Return the Recommendation object
        return new Recommendation(patient.userId, advice);
    },

    //Sends the alert to the patient and specialist.
    
    sendAlert: function(patientName, specialistEmail, message) {
        // --- STUDENT NOTE: Email API Placeholder ---
        // LATER: Integrate with a mail service like SendGrid or Nodemailer.
        // We ensure the message contains the AI's personalized suggestion!
        console.log(`[Alert System]: Sending URGENT NOTIFICATION to **${patientName}** and Specialist: **${specialistEmail}**`);
        console.log(`[Alert Message]: ${message}`);
        [cite_start]console.log(`[Alert Sent Time]: ${new Date().toLocaleTimeString()} (Simulating within 15 minutes requirement) [cite: 194]`);
    }
};


//testing 


// setting up Patient and Specialist Info
const patientB = new Patient(201, 'Bishwas Aryal', 'dr.williams@clinic.com');

// Simulate Readings over the last 7 days (Abnormal Readings: 4 - Trigger should fire)
// We are deliberately associating abnormal readings with a specific food ('Pasta').
const now = Date.now();
const oneDay = 24 * 60 * 60 * 1000;

// Abnormal #1 (Day 1) - Trigger: Pasta
patientB.inputReading(255, 'Pasta', 'None', 'Felt very tired', new Date(now - 6 * oneDay)); 
// Normal reading
patientB.inputReading(110, 'Salad', 'Walk', '', new Date(now - 5 * oneDay)); 
// Abnormal #2 (Day 3) - Trigger: Pasta
patientB.inputReading(240, 'Pasta', 'Gym', '', new Date(now - 4 * oneDay));
// Borderline reading
patientB.inputReading(170, 'Soup', 'Walk', '', new Date(now - 3 * oneDay)); 
// Abnormal #3 (Day 5) - Trigger: Pasta (Breaches the 3 count!)
patientB.inputReading(300, 'Pasta', 'None', 'Nausea', new Date(now - 2 * oneDay)); 
// Normal reading
patientB.inputReading(135, 'Chicken', 'Walk', '', new Date(now - 1 * oneDay)); 
// Abnormal #4 (Day 7/Today) - Trigger: Pizza (A different food)
patientB.inputReading(210, 'Pizza', 'None', '', new Date(now)); 


// 3. Run the Automated AI Alert Check
AIEngine.runAlertCheck(patientB);